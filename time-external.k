module TIME-EXTERNAL 

    imports DOMAINS

    syntax AllTime ::= TimeOfDate
                | Time
                | Date
                | DateAndTime
    syntax AllTimes ::= TimeOfDates
                | Times
                | Dates
                | DateAndTimes

    syntax TimeOfDate ::= "TOD#" Int ":" Int ":" Int "." Int
    syntax TimeOfDates ::= r"(TOD[\\#](([0-1]?[0-9])|([2][0-4]))[:][0-5]?[0-9][:][0-5]?[0-9]([.][0-9]{1,3})?)|(TIME_OF_DAY[\\#](([0-1]?[0-9])|([2][0-4]))[:][0-5]?[0-9][:][0-5]?[0-9]([.][0-9]{1,3})?)"       [token]
    syntax String ::= TimeOfDatesToString(TimeOfDates)                  [function,functional,hook(STRING.token2string)]
    rule TODs:TimeOfDates => TOD# String2Int(substrString(TimeOfDatesToString(TODs),findString(TimeOfDatesToString(TODs),"#",0) +Int 1,findString(TimeOfDatesToString(TODs),":",4))) : String2Int(substrString(TimeOfDatesToString(TODs),findString(TimeOfDatesToString(TODs),":",4) +Int 1,findString(TimeOfDatesToString(TODs),":",findString(TimeOfDatesToString(TODs),":",4) +Int 1))) : String2Int(substrString(TimeOfDatesToString(TODs),findString(TimeOfDatesToString(TODs),":",findString(TimeOfDatesToString(TODs),":",4) +Int 1) +Int 1,findString(TimeOfDatesToString(TODs),".",0))) . String2Int(substrString(TimeOfDatesToString(TODs),findString(TimeOfDatesToString(TODs),".",0) +Int 1,lengthString(TimeOfDatesToString(TODs)))) requires findString(TimeOfDatesToString(TODs),".",0) >=Int 0
    rule TODs:TimeOfDates => TOD# String2Int(substrString(TimeOfDatesToString(TODs),findString(TimeOfDatesToString(TODs),"#",0) +Int 1,findString(TimeOfDatesToString(TODs),":",4))) : String2Int(substrString(TimeOfDatesToString(TODs),findString(TimeOfDatesToString(TODs),":",4) +Int 1,findString(TimeOfDatesToString(TODs),":",findString(TimeOfDatesToString(TODs),":",4) +Int 1))) : String2Int(substrString(TimeOfDatesToString(TODs),findString(TimeOfDatesToString(TODs),":",findString(TimeOfDatesToString(TODs),":",4) +Int 1) +Int 1,lengthString(TimeOfDatesToString(TODs)))) . 0 requires findString(TimeOfDatesToString(TODs),".",0) ==Int -1
    rule TOD# I1:Int : I2:Int : I3:Int . I4:Int => TOD# ((I1 +Int ((I2 +Int ((I3 +Int (I4 /Int 1000)) /Int 60)) /Int 60)) modInt 24) : ((I2 +Int ((I3 +Int (I4 /Int 1000)) /Int 60)) modInt 60) : ((I3 +Int (I4 /Int 1000)) modInt 60) . (I4 modInt 1000) requires (I1 >=Int 24 orBool I2 >=Int 60 orBool I3 >=Int 60 orBool I4 >=Int 1000)  [anywhere]

    syntax Time ::= "T#" Int "d" Int "h" Int "m" Int "s" Int "ms"
    syntax Times ::= r"(T[\\#]([0-9]*[d])?((([0-1][0-9])|([2][0-4]))[h])?(([0-5][0-9])[m])?(([0-5][0-9])[s])?(([0-9]{3})[m][s])?)|(TIME[\\#]([0-4][0-9][d])?((([0-1][0-9])|([2][0-4]))[h])?(([0-5][0-9])[m])?(([0-5][0-9])[s])?(([0-9]{3})[m][s])?)"                            [token]
    syntax String ::= TimesToString(Times)                               [function, functional, hook(STRING.token2string)]
    rule Ts:Times => T# String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,Int2One(findString(("0" +String TimesToString(Ts)),"d",0)) *Int (findString(("0" +String TimesToString(Ts)),"#",0) +Int 1)),maxInt(1,findString(("0" +String TimesToString(Ts)),"d",0)))) d String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,findString(("0" +String TimesToString(Ts)),"h",0) -Int 2),maxInt(1,findString(("0" +String TimesToString(Ts)),"h",0)))) h String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,findString(("0" +String TimesToString(Ts)),"m",0) -Int 2),maxInt(1,findString(("0" +String TimesToString(Ts)),"m",0)))) m String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,findString(("0" +String TimesToString(Ts)),"s",0) -Int 2),maxInt(1,findString(("0" +String TimesToString(Ts)),"s",0)))) s String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,findString(("0" +String TimesToString(Ts)),"ms",0) -Int 3),maxInt(1,findString(("0" +String TimesToString(Ts)),"ms",0)))) ms requires (findString(("0" +String TimesToString(Ts)),"m",0) ==Int -1 orBool findString(("0" +String TimesToString(Ts)),"m",0) =/=Int findString(("0" +String TimesToString(Ts)),"ms",0)) andBool (findString(("0" +String TimesToString(Ts)),"s",0) ==Int -1 orBool findString(("0" +String TimesToString(Ts)),"s",0) =/=Int (findString(("0" +String TimesToString(Ts)),"ms",0) +Int 1))
    rule Ts:Times => T# String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,Int2One(findString(("0" +String TimesToString(Ts)),"d",0)) *Int (findString(("0" +String TimesToString(Ts)),"#",0) +Int 1)),maxInt(1,findString(("0" +String TimesToString(Ts)),"d",0)))) d String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,findString(("0" +String TimesToString(Ts)),"h",0) -Int 2),maxInt(1,findString(("0" +String TimesToString(Ts)),"h",0)))) h 0 m String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,findString(("0" +String TimesToString(Ts)),"s",0) -Int 2),maxInt(1,findString(("0" +String TimesToString(Ts)),"s",0)))) s String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,findString(("0" +String TimesToString(Ts)),"ms",0) -Int 3),maxInt(1,findString(("0" +String TimesToString(Ts)),"ms",0)))) ms requires (findString(("0" +String TimesToString(Ts)),"m",0) =/=Int -1 andBool findString(("0" +String TimesToString(Ts)),"m",0) ==Int findString(("0" +String TimesToString(Ts)),"ms",0)) andBool (findString(("0" +String TimesToString(Ts)),"s",0) ==Int -1 orBool findString(("0" +String TimesToString(Ts)),"s",0) =/=Int (findString(("0" +String TimesToString(Ts)),"ms",0) +Int 1))
    rule Ts:Times => T# String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,Int2One(findString(("0" +String TimesToString(Ts)),"d",0)) *Int (findString(("0" +String TimesToString(Ts)),"#",0) +Int 1)),maxInt(1,findString(("0" +String TimesToString(Ts)),"d",0)))) d String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,findString(("0" +String TimesToString(Ts)),"h",0) -Int 2),maxInt(1,findString(("0" +String TimesToString(Ts)),"h",0)))) h String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,findString(("0" +String TimesToString(Ts)),"m",0) -Int 2),maxInt(1,findString(("0" +String TimesToString(Ts)),"m",0)))) m 0 s String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,findString(("0" +String TimesToString(Ts)),"ms",0) -Int 3),maxInt(1,findString(("0" +String TimesToString(Ts)),"ms",0)))) ms requires (findString(("0" +String TimesToString(Ts)),"m",0) ==Int -1 orBool findString(("0" +String TimesToString(Ts)),"m",0) =/=Int findString(("0" +String TimesToString(Ts)),"ms",0)) andBool (findString(("0" +String TimesToString(Ts)),"s",0) =/=Int -1 andBool findString(("0" +String TimesToString(Ts)),"s",0) ==Int (findString(("0" +String TimesToString(Ts)),"ms",0) +Int 1))
    rule Ts:Times => T# String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,Int2One(findString(("0" +String TimesToString(Ts)),"d",0)) *Int (findString(("0" +String TimesToString(Ts)),"#",0) +Int 1)),maxInt(1,findString(("0" +String TimesToString(Ts)),"d",0)))) d String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,findString(("0" +String TimesToString(Ts)),"h",0) -Int 2),maxInt(1,findString(("0" +String TimesToString(Ts)),"h",0)))) h 0 m 0 s String2Int(substrString("0" +String TimesToString(Ts),maxInt(0,findString(("0" +String TimesToString(Ts)),"ms",0) -Int 3),maxInt(1,findString(("0" +String TimesToString(Ts)),"ms",0)))) ms requires (findString(("0" +String TimesToString(Ts)),"m",0) =/=Int -1 andBool findString(("0" +String TimesToString(Ts)),"m",0) ==Int findString(("0" +String TimesToString(Ts)),"ms",0)) andBool (findString(("0" +String TimesToString(Ts)),"s",0) =/=Int -1 andBool findString(("0" +String TimesToString(Ts)),"s",0) ==Int (findString(("0" +String TimesToString(Ts)),"ms",0) +Int 1))
    rule T# I1:Int d I2:Int h I3:Int m I4:Int s I5:Int ms => T# (I1 +Int ((I2 +Int ((I3 +Int ((I4 +Int (I5 /Int 1000)) /Int 60)) /Int 60)) /Int 24)) d ((I2 +Int ((I3 +Int ((I4 +Int (I5 /Int 1000)) /Int 60)) /Int 60)) modInt 24) h ((I3 +Int ((I4 +Int (I5 /Int 1000)) /Int 60)) modInt 60) m ((I4 +Int (I5 /Int 1000)) modInt 60) s (I5 modInt 1000) ms  requires  (I2 >=Int 24 orBool I3 >=Int 60 orBool I4 >=Int 60 orBool I5 >=Int 1000)        [anywhere]
    syntax Int ::= Int2One(Int)                      [function,functional]
    rule Int2One(I:Int) => 1 requires I >Int 0
    rule Int2One(I:Int) => 0 requires I ==Int 0
    rule Int2One(I:Int) => -1 requires I <Int 0

    syntax Date ::= "D#" Int "-" Int "-" Int
    syntax Dates ::= r"(D[\\#](([1][9][7-9][0-9])|([2][0][0-9][0-9])|([2][1][0][0-6]))[-](([1][0-2])|([0]?[0-9]))[-](([0-2]?[0-9])|([3][0-1])))|(DATE[\\#](([1][9][7-9][0-9])|([2][0][0-9][0-9])|([2][1][0][0-6]))[-](([1][0-2])|([0]?[0-9]))[-](([0-2]?[0-9])|([3][0-1])))"                              [token]
    syntax String ::= DatesToString(Dates)                               [function, functional, hook(STRING.token2string)]
    rule Ds:Dates => D# String2Int(substrString(DatesToString(Ds),findString(DatesToString(Ds),"#",0) +Int 1, findString(DatesToString(Ds),"-",0))) - String2Int(substrString(DatesToString(Ds),findString(DatesToString(Ds),"-",0) +Int 1,findString(DatesToString(Ds),"-",findString(DatesToString(Ds),"-",0) +Int 1))) - String2Int(substrString(DatesToString(Ds),findString(DatesToString(Ds),"-",findString(DatesToString(Ds),"-",0) +Int 1) +Int 1,lengthString(DatesToString(Ds))))
    syntax Int ::= Bool2Int(Bool)               [function,functional]
    rule Bool2Int(true) => 1
    rule Bool2Int(false) => 0                             
    rule D# I1:Int - I2:Int - I3:Int => D#  (I1 +Int Bool2Int((I2 +Int Bool2Int(I3 >Int 31) *Int 1) >Int 12) *Int 1) - ((I2 +Int Bool2Int(I3 >Int 31) *Int 1) -Int Bool2Int((I2 +Int Bool2Int(I3 >Int 31) *Int 1) >Int 12) *Int 12) - (I3 -Int Bool2Int(I3 >Int 31) *Int 31) requires (I2 >Int 12 orBool I3 >Int 31) andBool (I2 ==Int 1 orBool I2 ==Int 3 orBool I2 ==Int 5 orBool I2 ==Int 7 orBool I2 ==Int 8 orBool I2 ==Int 10 orBool I2 ==Int 12)   [anywhere]
    rule D# I1:Int - I2:Int - I3:Int => D#  (I1 +Int Bool2Int((I2 +Int Bool2Int(I3 >Int 30) *Int 1) >Int 12) *Int 1) - ((I2 +Int Bool2Int(I3 >Int 30) *Int 1) -Int Bool2Int((I2 +Int Bool2Int(I3 >Int 30) *Int 1) >Int 12) *Int 12) - (I3 -Int Bool2Int(I3 >Int 30) *Int 30) requires (I2 >Int 12 orBool I3 >Int 30) andBool (I2 ==Int 4 orBool I2 ==Int 6 orBool I2 ==Int 9 orBool I2 ==Int 11)   [anywhere]
    rule D# I1:Int - I2:Int - I3:Int => D#  (I1 +Int Bool2Int((I2 +Int Bool2Int(I3 >Int 29) *Int 1) >Int 12) *Int 1) - ((I2 +Int Bool2Int(I3 >Int 29) *Int 1) -Int Bool2Int((I2 +Int Bool2Int(I3 >Int 29) *Int 1) >Int 12) *Int 12) - (I3 -Int Bool2Int(I3 >Int 29) *Int 29) requires (I2 >Int 12 orBool I3 >Int 29) andBool (I2 ==Int 2 andBool ((I1 modInt 400) ==Int 0 orBool ((I1 modInt 100) =/=Int 0 andBool (I1 modInt 4) ==Int 0)))   [anywhere]
    rule D# I1:Int - I2:Int - I3:Int => D#  (I1 +Int Bool2Int((I2 +Int Bool2Int(I3 >Int 28) *Int 1) >Int 12) *Int 1) - ((I2 +Int Bool2Int(I3 >Int 28) *Int 1) -Int Bool2Int((I2 +Int Bool2Int(I3 >Int 28) *Int 1) >Int 12) *Int 12) - (I3 -Int Bool2Int(I3 >Int 28) *Int 28) requires (I2 >Int 12 orBool I3 >Int 28) andBool (I2 ==Int 2 andBool notBool ((I1 modInt 400) ==Int 0 orBool ((I1 modInt 100) =/=Int 0 andBool (I1 modInt 4) ==Int 0)))   [anywhere]
    rule D# I1:Int - I2:Int - I3:Int => D# (I1 -Int 1) - 12 - 31   requires (I2 ==Int 0 andBool I3 ==Int 0)     [anywhere]
    rule D# I1:Int - I2:Int - I3:Int => D# (I1 -Int 1) - 12 - I3   requires (I2 ==Int 0 andBool I3 =/=Int 0)     [anywhere]
    rule D# I1:Int - I2:Int - I3:Int => D# I1 - (I2 -Int 1) - 31   requires (I2 =/=Int 0 andBool I3 ==Int 0) andBool ((I2 -Int 1) ==Int 1 orBool (I2 -Int 1) ==Int 3 orBool (I2 -Int 1) ==Int 5 orBool (I2 -Int 1) ==Int 7 orBool (I2 -Int 1) ==Int 8 orBool (I2 -Int 1) ==Int 10 orBool (I2 -Int 1) ==Int 0)        [anywhere]
    rule D# I1:Int - I2:Int - I3:Int => D# I1 - (I2 -Int 1) - 30   requires (I2 =/=Int 0 andBool I3 ==Int 0) andBool ((I2 -Int 1) ==Int 4 orBool (I2 -Int 1) ==Int 6 orBool (I2 -Int 1) ==Int 9 orBool (I2 -Int 1) ==Int 11)        [anywhere]
    rule D# I1:Int - I2:Int - I3:Int => D# I1 - (I2 -Int 1) - 29   requires (I2 =/=Int 0 andBool I3 ==Int 0) andBool ((I2 -Int 1) ==Int 2 andBool ((I1 modInt 400) ==Int 0 orBool ((I1 modInt 100) =/=Int 0 andBool (I1 modInt 4) ==Int 0)))        [anywhere]
    rule D# I1:Int - I2:Int - I3:Int => D# I1 - (I2 -Int 1) - 28   requires (I2 =/=Int 0 andBool I3 ==Int 0) andBool ((I2 -Int 1) ==Int 2 andBool notBool ((I1 modInt 400) ==Int 0 orBool ((I1 modInt 100) =/=Int 0 andBool (I1 modInt 4) ==Int 0)))        [anywhere]

    syntax DateAndTime ::= "DT#" Int "-" Int "-" Int "-" Int ":" Int ":" Int
    syntax DateAndTimes ::= r"(DT[\\#](([1][9][7-9][0-9])|([2][0][0-9][0-9])|([2][1][0][0-6]))[-](([1][0-2])|([0]?[0-9]))[-](([0-2]?[0-9])|([3-6][0-9]))[-](([0-1]?[0-9])|([2][0-4]))[:][0-5]?[0-9][:][0-5]?[0-9])|(DATE_AND_TIME[\\#](([1][9][7-9][0-9])|([2][0][0-9][0-9])|([2][1][0][0-6]))[-](([1][0-2])|([0]?[0-9]))[-](([0-2]?[0-9])|([3][0-1]))[-](([0-1]?[0-9])|([2][0-4]))[:][0-5]?[0-9][:][0-5]?[0-9])" [token]//)|(DATE_AND_TIME[\\#]([1][9][7-9][0-9]|[2][0][0-9][0-9]|[2][1][0][0-6])[-]([1][0-2]|[0-9])[-]([0-2]?[0-9]|[3][0-1])[-]([0-1]?[0-9]|[2][0-4])[:][0-5]?[0-9][:][0-5]?[0-9])"                              [token]
    syntax String ::= DateAndTimesToString(DateAndTimes)                  [function,functional, hook(STRING.token2string)]
    rule DATs:DateAndTimes => DT# String2Int(substrString(DateAndTimesToString(DATs),findString(DateAndTimesToString(DATs),"#",0) +Int 1, findString(DateAndTimesToString(DATs),"-",0))) - String2Int(substrString(DateAndTimesToString(DATs),findString(DateAndTimesToString(DATs),"-",0) +Int 1,findString(DateAndTimesToString(DATs),"-",findString(DateAndTimesToString(DATs),"-",0) +Int 1))) - String2Int(substrString(DateAndTimesToString(DATs),findString(DateAndTimesToString(DATs),"-",findString(DateAndTimesToString(DATs),"-",0) +Int 1) +Int 1, findString(DateAndTimesToString(DATs),"-",findString(DateAndTimesToString(DATs),"-", findString(DateAndTimesToString(DATs),"-",0) +Int 1) +Int 1))) - String2Int(substrString(DateAndTimesToString(DATs),findString(DateAndTimesToString(DATs),"-",findString(DateAndTimesToString(DATs),"-",findString(DateAndTimesToString(DATs),"-",0) +Int 1) +Int 1) +Int 1, findString(DateAndTimesToString(DATs),":",0))) : String2Int(substrString(DateAndTimesToString(DATs),findString(DateAndTimesToString(DATs),":",0) +Int 1,findString(DateAndTimesToString(DATs),":",findString(DateAndTimesToString(DATs),":",0) +Int 1))) : String2Int(substrString(DateAndTimesToString(DATs),findString(DateAndTimesToString(DATs),":",findString(DateAndTimesToString(DATs),":",0) +Int 1) +Int 1, lengthString(DateAndTimesToString(DATs))))
    rule DT# I1:Int - I2:Int - I3:Int - I4:Int : I5:Int : I6:Int => DT# (I1 +Int Bool2Int((I2 +Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 31) *Int 1) >Int 12) *Int 1) - ((I2 +Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 31) *Int 1) -Int Bool2Int((I2 +Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 31) *Int 1) >Int 12) *Int 12) - ((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) -Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 31) *Int 31) - ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) modInt 24) : ((I5 +Int (I6 /Int 1000)) modInt 60) : (I6 modInt 1000) requires (I2 >Int 12 orBool I3 >Int 31 orBool I4 >=Int 24 orBool I5 >=Int 60 orBool I6 >=Int 60) andBool  (I2 ==Int 1 orBool I2 ==Int 3 orBool I2 ==Int 5 orBool I2 ==Int 7 orBool I2 ==Int 8 orBool I2 ==Int 10 orBool I2 ==Int 12)    [anywhere]
    rule DT# I1:Int - I2:Int - I3:Int - I4:Int : I5:Int : I6:Int => DT# (I1 +Int Bool2Int((I2 +Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 30) *Int 1) >Int 12) *Int 1) - ((I2 +Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 30) *Int 1) -Int Bool2Int((I2 +Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 30) *Int 1) >Int 12) *Int 12) - ((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) -Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 30) *Int 30) - ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) modInt 24) : ((I5 +Int (I6 /Int 1000)) modInt 60) : (I6 modInt 1000) requires (I2 >Int 12 orBool I3 >Int 30 orBool I4 >=Int 24 orBool I5 >=Int 60 orBool I6 >=Int 60) andBool  (I2 ==Int 4 orBool I2 ==Int 6 orBool I2 ==Int 9 orBool I2 ==Int 11)     [anywhere]
    rule DT# I1:Int - I2:Int - I3:Int - I4:Int : I5:Int : I6:Int => DT# (I1 +Int Bool2Int((I2 +Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 29) *Int 1) >Int 12) *Int 1) - ((I2 +Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 29) *Int 1) -Int Bool2Int((I2 +Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 29) *Int 1) >Int 12) *Int 12) - ((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) -Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 31) *Int 29) - ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) modInt 24) : ((I5 +Int (I6 /Int 1000)) modInt 60) : (I6 modInt 1000) requires (I2 >Int 12 orBool I3 >Int 29 orBool I4 >=Int 24 orBool I5 >=Int 60 orBool I6 >=Int 60) andBool  (I2 ==Int 2 andBool ((I1 modInt 400) ==Int 0 orBool ((I1 modInt 100) =/=Int 0 andBool (I1 modInt 4) ==Int 0)))     [anywhere]
    rule DT# I1:Int - I2:Int - I3:Int - I4:Int : I5:Int : I6:Int => DT# (I1 +Int Bool2Int((I2 +Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 28) *Int 1) >Int 12) *Int 1) - ((I2 +Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 28) *Int 1) -Int Bool2Int((I2 +Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 28) *Int 1) >Int 12) *Int 12) - ((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) -Int Bool2Int((I3 +Int ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) /Int 24)) >Int 31) *Int 28) - ((I4 +Int ((I5 +Int (I6 /Int 1000)) /Int 60)) modInt 24) : ((I5 +Int (I6 /Int 1000)) modInt 60) : (I6 modInt 1000) requires (I2 >Int 12 orBool I3 >Int 28 orBool I4 >=Int 24 orBool I5 >=Int 60 orBool I6 >=Int 60) andBool  (I2 ==Int 2 andBool notBool ((I1 modInt 400) ==Int 0 orBool ((I1 modInt 100) =/=Int 0 andBool (I1 modInt 4) ==Int 0)))     [anywhere]
    rule DT# I1:Int - I2:Int - I3:Int - I4:Int : I5:Int : I6:Int => DT# (I1 -Int 1) - 12 - 31 - I4 : I5 : I6   requires (I2 ==Int 0 andBool I3 ==Int 0)     [anywhere]
    rule DT# I1:Int - I2:Int - I3:Int - I4:Int : I5:Int : I6:Int => DT# (I1 -Int 1) - 12 - I3 - I4 : I5 : I6   requires (I2 ==Int 0 andBool I3 =/=Int 0)     [anywhere]
    rule DT# I1:Int - I2:Int - I3:Int - I4:Int : I5:Int : I6:Int => DT# I1 - (I2 -Int 1) - 31 - I4 : I5 : I6   requires (I2 =/=Int 0 andBool I3 ==Int 0) andBool ((I2 -Int 1) ==Int 1 orBool (I2 -Int 1) ==Int 3 orBool (I2 -Int 1) ==Int 5 orBool (I2 -Int 1) ==Int 7 orBool (I2 -Int 1) ==Int 8 orBool (I2 -Int 1) ==Int 10 orBool (I2 -Int 1) ==Int 0)        [anywhere]
    rule DT# I1:Int - I2:Int - I3:Int - I4:Int : I5:Int : I6:Int => DT# I1 - (I2 -Int 1) - 30 - I4 : I5 : I6   requires (I2 =/=Int 0 andBool I3 ==Int 0) andBool ((I2 -Int 1) ==Int 4 orBool (I2 -Int 1) ==Int 6 orBool (I2 -Int 1) ==Int 9 orBool (I2 -Int 1) ==Int 11)        [anywhere]
    rule DT# I1:Int - I2:Int - I3:Int - I4:Int : I5:Int : I6:Int => DT# I1 - (I2 -Int 1) - 29 - I4 : I5 : I6   requires (I2 =/=Int 0 andBool I3 ==Int 0) andBool ((I2 -Int 1) ==Int 2 andBool ((I1 modInt 400) ==Int 0 orBool ((I1 modInt 100) =/=Int 0 andBool (I1 modInt 4) ==Int 0)))        [anywhere]
    rule DT# I1:Int - I2:Int - I3:Int - I4:Int : I5:Int : I6:Int => DT# I1 - (I2 -Int 1) - 28 - I4 : I5 : I6   requires (I2 =/=Int 0 andBool I3 ==Int 0) andBool ((I2 -Int 1) ==Int 2 andBool notBool ((I1 modInt 400) ==Int 0 orBool ((I1 modInt 100) =/=Int 0 andBool (I1 modInt 4) ==Int 0)))        [anywhere]

endmodule